<!doctype html><html><head><meta charset=utf-8><meta name=generator content="Hugo 0.107.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><meta name=keywords content><meta name=description content="A note on the fundamentals of C++ language"><meta name=author content="Kaga Ryousuke"><meta name=copyright content="Kaga Ryousuke"><meta http-equiv=content-language content="zh,en"><link rel=canonical href=http://blairablakeblog.s3-website-ap-northeast-1.amazonaws.com/c++/c++-fundamentals/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Fundamentals of C++ language&nbsp;&ndash;&nbsp;Blog</title><link rel=preconnect href=https://cdn.jsdelivr.net/ crossorigin><link rel=dns-prefetch href=https://cdn.jsdelivr.net/><link rel=dns-prefetch href=https://fonts.gstatic.com/><link rel=preload href=/css/core.min.7fea1f5a41ad0e665eeb874055b0e68e8a11091c60801d2e241269731df6f3b4cd1871c64da457ede9e3d44dcee5732b.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/css/core.min.7fea1f5a41ad0e665eeb874055b0e68e8a11091c60801d2e241269731df6f3b4cd1871c64da457ede9e3d44dcee5732b.css integrity=sha384-f+ofWkGtDmZe64dAVbDmjooRCRxggB0uJBJpcx3287TNGHHGTaRX7enj1E3O5XMr></noscript><style type=text/css>*,::before,::after{margin:0;padding:0;box-sizing:border-box}html{font-family:-system-ui,-apple-system,BlinkMacSystemFont,helvetica neue,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;font-size:17px;font-weight:400;line-height:2;scroll-behavior:smooth;transition:color .3s,background-color .3s;word-wrap:break-word;-webkit-text-size-adjust:100%}html[data-theme=dark] img{opacity:.7;transition:opacity .5s ease-in-out}html{background:#fff;--site-name-color:#3f4b67;--color-primary:#005ab4;--link-underline:#90cff9;--blockquote-border-left:6px solid #0051a2;--block-background-color:#f7faff;--pag-background-color:rgba(0, 122, 255, .5);--box-shadow:1px 1px 2px rgba(0,0,0,.125);--title-color:#303033;--body-color:#444}html[data-theme=dark]{background:#22272e;--site-name-color:#539bf5;--color-primary:#99bde1;--link-underline:#0051a2;--blockquote-border-left:6px solid #5176bf;--block-background-color:#002c58;--box-shadow:none;--title-color:#dadada;--body-color:#e9e9e9}h1,h2,h3,h4,h5,h6{font-weight:600;line-height:1;margin-block-start:0;margin-block-end:0}h1{font-size:26px}h2{font-size:24px}h3{font-size:22px}section>h1{color:var(--title-color)}a{color:var(--color-primary);text-decoration-thickness:.2rem;text-decoration-color:var(--link-underline)}a:hover{text-decoration-color:var(--color-primary)}.wrapper{display:grid;grid-template-columns:1fr min(65ch,calc(100% - 64px))1fr;grid-column-gap:32px}.wrapper>section{grid-column:2}.header{margin:20px 0;display:-webkit-flex;display:flex;flex-wrap:wrap;text-align:initial;padding:15px 0;border-bottom:1px solid #f0f0f0;justify-content:space-between;align-items:baseline}.site-name{display:inline-block;font-weight:600;font-size:21px;color:var(--site-name-color)}.site-logo{height:38px;border-radius:3px;vertical-align:middle;margin-right:8px}.nav-item{display:inline-block;font-size:18px;padding:4px 6px;margin:2px 3px 2px 0;line-height:2;white-space:nowrap}.data-theme-btn{border:none;vertical-align:middle;transition:.3s;background-color:Transparent;background-repeat:no-repeat;cursor:pointer;overflow:hidden;outline:none;padding-right:0;padding-left:0}html[data-theme=light] .light-hidden{display:none}html[data-theme=dark] .dark-hidden{display:none}.note-list{margin:0;padding:0;list-style:none}.note-list .item{position:relative;width:100%;margin-top:25px}.note-list .item:last-child{border:0!important}.note-title{font-size:19px;font-weight:700}.note-date,.note-content{font-size:15px;text-decoration:none;color:var(--body-color)}.note-content,.note-imgs,.note-labels{margin-top:4px;text-align:justify;text-justify:inter-word}.article-tag,.article-category{display:inline-block;font-size:15px;line-height:1;padding:4px 6px;margin:2px 3px 2px 0;white-space:nowrap;border-radius:3px}.article-category{color:#3a8c42}.article-category .hashtag,.article-tag .hashtag{font-weight:700;opacity:.5}.footer{font-size:13px;margin:40px 0 20px}.footer-wrap{text-align:center;color:var(--body-color)}.tag-cloud{margin:2em 0 3em;text-align:center}.tag-cloud-tags{display:inline-block;position:relative;margin:5px;word-wrap:break-word;overflow-wrap:break-word}.archive-year{font-size:20px;font-weight:800;color:var(--title-color);margin-top:20px;margin-bottom:10px}.archive-list{list-style:none}.archive-date{flex:0 0 100px;color:var(--title-color)}.archive-text{color:var(--body-color)}ul.archive-list li{display:flex}.article-containter{margin-bottom:20px}.article-header{margin:20px 0}.article-date{font-size:14px;margin-top:20px;color:#838387}.lastmod-date{font-size:14px;color:#838387}.markdown-body{color:var(--body-color)}.markdown-body p{margin-top:0;margin-bottom:20px}.pagination{display:block;text-align:center;margin:20px 0 40px}.pagination ul{display:inline-block;list-style:none;font-weight:600;padding:0;margin:0}.pagination ul li{display:inline}.pagination ul li a{color:var(--color-primary);float:left;padding:8px 16px;text-decoration:none}.pagination ul li a:hover:not(.active){background-color:var(--pag-background-color)}.pagination ul li a.active{background-color:var(--color-primary);color:var(--block-background-color)}</style></head><body><div class=wrapper><section id=header class=header><div class=header-left><a href=/><img class=site-logo src=/images/logo.jpg alt><p class=site-name>Blog</p></a></div><div class=header-right><div class=nav><a class=nav-item href=/>Index</a><a class=nav-item href=/tags/>Tags</a><a class=nav-item href=/archives/>Archives</a><a class=nav-item href=/about/>About</a><script>const htmlEl=document.getElementsByTagName("html")[0],currentTheme=localStorage.getItem("theme")?localStorage.getItem("theme"):null;currentTheme&&(htmlEl.dataset.theme=currentTheme);const toggleTheme=e=>{htmlEl.dataset.theme=e,localStorage.setItem("theme",e)};toggleTheme("light")</script></div></div></section><section id=content><div class=article-containter><section class=article-header><h1>Fundamentals of C++ language</h1><p class=article-date>2023-09-09</p></section><section class=article-labels><a class="article-tag li" href=/tags/c++/><span class=hashtag>#</span>c++</a><a class="article-tag li" href=/tags/programming/><span class=hashtag>#</span>programming</a></section><article class=markdown-body><p>The execution of a C program begins with the main() function. Every C++ program must have exactly one global function named main().</p><h1 id=namespace>Namespace</h1><p>A namespace provides a scope to identifiers inside it and prevents name collisions.</p><p>Identifiers outside the namespace can access the member by using the fully quantified name, or use using directives.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>namespace</span> MyLibrary {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span>{
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>MyLibrary<span style=color:#ff79c6>::</span>A a1;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>using</span> MyLibrary<span style=color:#ff79c6>::</span>A;
</span></span><span style=display:flex><span>A a2;
</span></span></code></pre></div><h2 id=namespace-aliases>Namespace Aliases</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>namespace</span> AVLNN <span style=color:#ff79c6>=</span> a_very_long_namespace_name;
</span></span></code></pre></div><h2 id=anonymous-namespace>Anonymous Namespace</h2><p>An anonymous namespace make names inside it invisible to the code in other files. The code in the same file can access the names inside an anonymous namespace as if these are normal names.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>namespace</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span> {
</span></span><span style=display:flex><span>        ...
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A a;
</span></span></code></pre></div><p>In another file, we can&rsquo;t access to the class A.</p><h1 id=function-template>Function Template</h1><p>Function template allows us to write a function with a variable type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>template</span> <span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span>T greater(T a , T b) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> a <span style=color:#ff79c6>&gt;</span> b <span style=color:#ff79c6>?</span> <span style=color:#8be9fd;font-style:italic>a</span> : b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=calling-function-template>Calling Function Template</h2><p>To call a funcion template, we have to specify the type within angle brackets.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>greater<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>int</span><span style=color:#ff79c6>&gt;</span>(<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>1</span>);
</span></span></code></pre></div><p>When the type is a primitive type, we can omit the type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>greater(<span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>1</span>);
</span></span></code></pre></div><h2 id=template-specialization>Template Specialization</h2><p>Even if we were to define a type specific implementation, we must add template&lt;>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>template</span> <span style=color:#ff79c6>&lt;&gt;</span>
</span></span><span style=display:flex><span>MyType greater(MyType a, MyType b) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> a.x <span style=color:#ff79c6>&gt;</span> b.x <span style=color:#ff79c6>?</span> <span style=color:#8be9fd;font-style:italic>a</span> : b;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=class>Class</h1><p>A class is an blueprint for objects. A class creates its own scope and have attributes and behaviors. Attributes and behaviors are private (hidden) by default. I call the attributes and behaviors together members of the class.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> <span style=color:#50fa7b>increment</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To distinguish the private and public parts, we write</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span>{
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> increment();
</span></span><span style=display:flex><span><span style=color:#ff79c6>private</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=constructors>Constructors</h2><p>A class can include a special behavior called constructor, which is automatically called whenever a new object is created, allowing the class to initialize attributes.</p><p>Constructor function is declared just like a normal behavior, but with a name that mathces the class name and without any return type, not even void.</p><p>A classs can be treated like basic types.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> data;
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    A(<span style=color:#8be9fd>int</span> x) {
</span></span><span style=display:flex><span>        data <span style=color:#ff79c6>=</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Constructor can be overloaded.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span>{
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> data;
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    A(<span style=color:#8be9fd>int</span> x) {
</span></span><span style=display:flex><span>        data <span style=color:#ff79c6>=</span> x;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    A() {
</span></span><span style=display:flex><span>        data <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=uniform-initialization>Uniform Initialization</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>class_name object_name { v1, v2, ...}; <span style=color:#6272a4>// constructor is called
</span></span></span></code></pre></div><h2 id=attribute-initialization-in-constructor>Attribute Initialization in Constructor</h2><p>When a constructor is used to initialize attributes, these attributes can be initialized directly by inserting, before the constructor&rsquo;s body, a colon and a list of initialization for attributes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> data;
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    A(<span style=color:#8be9fd>int</span> x)<span style=color:#ff79c6>:</span> data(x) {}; 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=accessing-members>Accessing Members</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>object.member
</span></span><span style=display:flex><span>object_pointer<span style=color:#ff79c6>-&gt;</span>member
</span></span></code></pre></div><h2 id=the-keyword-this>The Keyword: this</h2><p>The keyword &ldquo;this&rdquo; represents a pointer to the object whose behavior function is being executed.
It is used within a class&rsquo;s behavior function to refer to the object itself.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span> {
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    A<span style=color:#ff79c6>*</span> dosomething() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A a1;
</span></span><span style=display:flex><span>a1.dosomething() <span style=color:#6272a4>// return a pointer to a1 object itself
</span></span></span></code></pre></div><h2 id=static-members>Static Members</h2><p>A static member of a class is an member which is shared across all the object of the same class. It can be refered to as an member of an object or even directly by the class name.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span>{
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>static</span> <span style=color:#8be9fd>int</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>A a1;
</span></span><span style=display:flex><span>a1.x <span style=color:#ff79c6>==</span> A<span style=color:#ff79c6>::</span>x <span style=color:#6272a4>// true
</span></span></span></code></pre></div><h2 id=class-template>Class Template</h2><p>Template allows the parametrization of types, and we can use template for a class in the same way as a function template.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>template</span> <span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span>{
</span></span><span style=display:flex><span>    T x;
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    T getX();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>template</span> <span style=color:#ff79c6>&lt;</span><span style=color:#ff79c6>typename</span> T<span style=color:#ff79c6>&gt;</span>
</span></span><span style=display:flex><span>T A<span style=color:#ff79c6>&lt;</span>T<span style=color:#ff79c6>&gt;::</span>getX() {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> x;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=overloading-operators>Overloading Operators</h2><p>Operators are overloaded by means of operator functions, which are regular function with special names: operator keyword followed by the operator sign.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>return_type <span style=color:#ff79c6>operator</span> <span style=color:#50fa7b>sign</span>(paramters){}
</span></span></code></pre></div><p>For the binary operators, paramters will be the reference to the right hand side of the operand.</p><h2 id=inheritance>Inheritance</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>derived_class_name</span> <span style=color:#ff79c6>:</span> <span style=color:#ff79c6>public</span> base_class_name {};
</span></span></code></pre></div><h2 id=protected-access-specifier>protected Access Specifier</h2><p>The members of the derived class can access the protected members inherited frpm the base class, but not its private members.</p><h2 id=setting-access-level>Setting Access Level</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>public</span> <span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>protected</span> <span style=color:#ff79c6>&gt;</span> <span style=color:#ff79c6>private</span>
</span></span></code></pre></div><p>We can set the highest access level of a base class by an access specifier after the colon.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span> <span style=color:#ff79c6>:</span> <span style=color:#ff79c6>private</span> B {};
</span></span></code></pre></div><p>In this case, all the member of B class become private members.</p><p>Note that this only specify the highest access level, so specifying it to be public doesn&rsquo;t mean all members become public members.</p><h2 id=friend>Friend</h2><p>friend keyword allows a function or a class to access the private members of a specified class.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>B</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> x;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>A</span> {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>friend</span> <span style=color:#ff79c6>class</span> <span style=color:#50fa7b>B</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>void</span> dosomething(B b) {
</span></span><span style=display:flex><span>        std<span style=color:#ff79c6>::</span>cout <span style=color:#ff79c6>&lt;&lt;</span> b.x <span style=color:#ff79c6>&lt;&lt;</span> std<span style=color:#ff79c6>::</span>endl; <span style=color:#6272a4>// able to access to the private members.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>friend keyword can specify the friendly functions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>B</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> x;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>friend</span> <span style=color:#8be9fd>void</span> <span style=color:#50fa7b>dosomething</span>(B b);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>dosomething</span>(B b) {
</span></span><span style=display:flex><span>    std<span style=color:#ff79c6>::</span>cout <span style=color:#ff79c6>&lt;&lt;</span> b.x <span style=color:#ff79c6>&lt;&lt;</span> std<span style=color:#ff79c6>::</span>endl; <span style=color:#6272a4>// able to access to private members.
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>}
</span></span></code></pre></div><h1 id=resources>Resources</h1><p>Resources are memory that has to be managed by programmer</p><h1 id=value-category>Value Category</h1><p>Every c++ expression belongs to a value category</p><ul><li>gvalue: an expression whose evaluation determins the identity of an object, or function.</li><li>prvalue: an expression whose evaluation initializes an object.</li><li>xvalue: a gvalue that denotes an object whose resources can be reused</li><li>lvalue: a gvalue that isn&rsquo;t a xvalue</li><li>rvalue a prvalue or an xvalue</li></ul><p><a target=_blank rel="noopener noreferrer" href=/images/value-category.png><img loading=lazy src=/images/value-category.png width=100% height=auto alt="value category"></a></p><h1 id=temporary-object>Temporary Object</h1><p>Temporary objects are unnamed objects. They are created as an effect of expression evaluation by the compiler and destoryed at the end of the expression or at the end of the controlling statements.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>UDT <span style=color:#50fa7b>func</span>(); <span style=color:#6272a4>// UDT == user defined type
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>func(); <span style=color:#6272a4>// A temporary object is created and then destoryed in this line.
</span></span></span></code></pre></div><h1 id=reference-type>Reference Type</h1><p>Reference store the address of an object.
After it&rsquo;s initialized, cannot be made to refer to a different obejct or set to null.</p><h2 id=two-kinds-of-references>Two Kinds of References</h2><ul><li>lvalue reference: reference to a named value</li><li>rvalue reference: reference to an unnamed value(temporary objects)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span>type_name name<span style=color:#ff79c6>&amp;</span>; <span style=color:#6272a4>//lvalue reference
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>type_name name<span style=color:#ff79c6>&amp;&amp;</span>; <span style=color:#6272a4>//rvalue reference
</span></span></span></code></pre></div><h1 id=resource-management>Resource Management</h1><h2 id=copy-constructor>copy-constructor</h2><p>When an object is passed a named object of its own type as argument, its copy-constructor is invoked in order to instruct a copy.</p><p>The copy-constructor behavior has the following signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>A<span style=color:#ff79c6>::</span>A(<span style=color:#ff79c6>const</span> A<span style=color:#ff79c6>&amp;</span>);
</span></span></code></pre></div><h2 id=copy-assignment>copy-assignment</h2><p>When an object is assgined a named object of its own type as arguemnt, its copy-assignment behavior is invoked.</p><p>The copy-assignment behavior has the follogin signature:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>A<span style=color:#ff79c6>&amp;</span> <span style=color:#ff79c6>operator</span><span style=color:#ff79c6>=</span>(<span style=color:#ff79c6>const</span> A<span style=color:#ff79c6>&amp;</span>);
</span></span></code></pre></div><h2 id=the-rule-of-five>The Rule of Five</h2><p>The rule of five states, simply said, that a class should completely handle its resources.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>Buffer</span> {
</span></span><span style=display:flex><span>    size_t size_{<span style=color:#bd93f9>0</span>};
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>float</span><span style=color:#ff79c6>*</span> ptr_{<span style=color:#ff79c6>nullptr</span>};
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span>
</span></span><span style=display:flex><span>    <span style=color:#6272a4>// std::initializer_list accepts a list constructed like {1, 2, ...}
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    <span style=color:#6272a4>// so Buffer can be constructed like Buffer({1, 2, ...});
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>    Buffer(<span style=color:#ff79c6>const</span> std<span style=color:#ff79c6>::</span>initializer_list<span style=color:#ff79c6>&lt;</span><span style=color:#8be9fd>float</span><span style=color:#ff79c6>&gt;&amp;</span> values)<span style=color:#ff79c6>:</span> size_{values.size()} {
</span></span><span style=display:flex><span>        ptr_ <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>float</span>[values.size()];
</span></span><span style=display:flex><span>        std<span style=color:#ff79c6>::</span>copy(values.begin(), values.end(), ptr_);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Buffer(<span style=color:#ff79c6>const</span> Buffer<span style=color:#ff79c6>&amp;</span> rhs)<span style=color:#ff79c6>:</span> size_{rhs.size_} {
</span></span><span style=display:flex><span>        ptr_ <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>float</span>[rhs.size_];
</span></span><span style=display:flex><span>        std<span style=color:#ff79c6>::</span>copy(rhs.ptr_, rhs.ptr_ <span style=color:#ff79c6>+</span> rhs.size_, ptr_);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    Buffer<span style=color:#ff79c6>&amp;</span> <span style=color:#ff79c6>operator</span><span style=color:#ff79c6>=</span>(<span style=color:#ff79c6>const</span> Buffer<span style=color:#ff79c6>&amp;</span> rhs) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>delete</span>[] ptr_;
</span></span><span style=display:flex><span>        ptr_ <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>new</span> <span style=color:#8be9fd>float</span>[rhs.size_];
</span></span><span style=display:flex><span>        size_ <span style=color:#ff79c6>=</span> rhs.size_;
</span></span><span style=display:flex><span>        std<span style=color:#ff79c6>::</span>copy(rhs.ptr_, rhs.ptr_ <span style=color:#ff79c6>+</span> rhs.size_, ptr_);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>*</span><span style=color:#ff79c6>this</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>~</span>Buffer() {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>delete</span>[] ptr_;
</span></span><span style=display:flex><span>        ptr_ <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>nullptr</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>auto</span> <span style=color:#50fa7b>begin</span>() <span style=color:#ff79c6>const</span> {<span style=color:#ff79c6>return</span> ptr_; }
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>auto</span> <span style=color:#50fa7b>end</span>() <span style=color:#ff79c6>const</span> {<span style=color:#ff79c6>return</span> ptr_ <span style=color:#ff79c6>+</span> size_; }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=the-problems-of-copying>The Problems of Copying</h2><ul><li><p>Some resources cannot be copied</p><p>The resource constained in a class might be a thread, a network connection, or something else that it&rsquo;s not possible to copy.</p></li><li><p>There are cases where copies are unnecessary</p><p>If we return the Buffer class, the entire array needs to be copied.</p></li></ul><h2 id=move-semantics>Move-semantics</h2><p>The solutions to these problem is move semantics. Moving differs from copying in that move transfers resources, meaning the moved-from object is deprived of its resources.</p><p>The && modifier indicates that the parameter is an object that we intend to move from instead of copying.</p><p>Note that it is a programmer who move the resources. We must transfer the resources and free the moved-from object from the resources.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#6272a4>//move-constructor
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>Buffer(Buffer<span style=color:#ff79c6>&amp;&amp;</span> rhs) <span style=color:#ff79c6>noexcept</span> <span style=color:#ff79c6>:</span> size_{rhs.size_}, ptr_{rhs.ptr_} {
</span></span><span style=display:flex><span>    rhs.ptr_ <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>nullptr</span>;
</span></span><span style=display:flex><span>    rhs.size_ <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#6272a4>//move-assignment
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>Buffer<span style=color:#ff79c6>&amp;</span> <span style=color:#ff79c6>operator</span><span style=color:#ff79c6>=</span>(Buffer<span style=color:#ff79c6>&amp;&amp;</span> rhs) <span style=color:#ff79c6>noexcept</span> {
</span></span><span style=display:flex><span>    ptr_ <span style=color:#ff79c6>=</span> rhs.ptr_;
</span></span><span style=display:flex><span>    size_ <span style=color:#ff79c6>=</span> rhs.size_;
</span></span><span style=display:flex><span>    rhs.ptr_ <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>nullptr</span>;
</span></span><span style=display:flex><span>    rhs.size_ <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>*</span><span style=color:#ff79c6>this</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Move doesn&rsquo;t allocate a new memory, so there doesn&rsquo;t arise any exception. &ldquo;noexcept&rdquo; indicates that.</p><p>Generally we transfer the resources in a unmaned object, or a temporary object like returned value from a function, but we can make the code to transfer the resources in a named object using std::move.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Buffer b1 {<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>, <span style=color:#bd93f9>3</span>};
</span></span><span style=display:flex><span>Buffer b2 { std<span style=color:#ff79c6>::</span>move(b1) }; <span style=color:#6272a4>// move constructor is called.
</span></span></span><span style=display:flex><span><span style=color:#6272a4>//b1 no longer has a resource after here.
</span></span></span></code></pre></div><h2 id=the-keyword-default>The Keyword: default</h2><p>By default, copy-constructor, copy-assignment, move-constructor, or move-assignment are defined by compiler implicitly.
However, if we define any of them, we must define all of them explicitly.</p><p>There is a case we only need to define only move-semantics, or copy-semantics. In that case, we can use default keyword:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>Buffer(Buffer<span style=color:#ff79c6>&amp;&amp;</span>) <span style=color:#ff79c6>noexcept</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>default</span>; 
</span></span><span style=display:flex><span>Buffer<span style=color:#ff79c6>&amp;</span> <span style=color:#ff79c6>operator</span><span style=color:#ff79c6>=</span>(Buffer<span style=color:#ff79c6>&amp;&amp;</span>) <span style=color:#ff79c6>noexcept</span> <span style=color:#ff79c6>=</span> <span style=color:#ff79c6>default</span>;
</span></span></code></pre></div><h1 id=automatic-type-deduction>Automatic Type Deduction</h1><p>auto keyword makes the compiler to deduce the type.
There are three variants of auto keyword.</p><table><thead><tr><th>Type</th><th>Meaning</th></tr></thead><tbody><tr><td>auto</td><td>value of a deduced type</td></tr><tr><td>auto&</td><td>reference to a named value of a deduced type</td></tr><tr><td>auto&&</td><td>reference to any value, including temporary value, of a deduced type</td></tr></tbody></table><h1 id=lambda-anonymous-function>Lambda (Anonymous Function)</h1><p>The signature for a lambda is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>[capture](arguments) {body};
</span></span></code></pre></div><h2 id=the-capture-clause>The Capture Clause</h2><p>A lambda can use externam variables inside lambda by capturing</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>auto</span> f <span style=color:#ff79c6>=</span> [x](<span style=color:#8be9fd>int</span> y) {<span style=color:#ff79c6>return</span> x <span style=color:#ff79c6>+</span> y};
</span></span></code></pre></div><h2 id=capture-by-reference>Capture by Reference</h2><p>We put & at the beginning:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span><span style=color:#ff79c6>auto</span> f1 <span style=color:#ff79c6>=</span> [x](<span style=color:#8be9fd>int</span> i) { <span style=color:#ff79c6>return</span> i <span style=color:#ff79c6>&gt;</span> x };
</span></span><span style=display:flex><span><span style=color:#ff79c6>auto</span> f2 <span style=color:#ff79c6>=</span> [<span style=color:#ff79c6>&amp;</span>x](<span style=color:#8be9fd>int</span> i) { <span style=color:#ff79c6>return</span> i <span style=color:#ff79c6>&gt;</span> x };
</span></span><span style=display:flex><span>x <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>10</span>;
</span></span><span style=display:flex><span>f1(<span style=color:#bd93f9>2</span>) <span style=color:#6272a4>// true, since x = 1
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>f2(<span style=color:#bd93f9>2</span>) <span style=color:#6272a4>// false, since x = 10
</span></span></span></code></pre></div><h2 id=lambda-and-function-objects>Lambda and Function Objects</h2><p>A function object, or functor is an instance of a class that has operator()() defined. Lambda expression is an syntactic sugar for creating function objects.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#8be9fd>int</span> x <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>auto</span> f1 <span style=color:#ff79c6>=</span> [x](<span style=color:#8be9fd>int</span> y){<span style=color:#ff79c6>return</span> x <span style=color:#ff79c6>+</span> y};
</span></span><span style=display:flex><span>f1(<span style=color:#bd93f9>1</span>);
</span></span></code></pre></div><p>is equivalent to</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>F1</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> y;
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span> 
</span></span><span style=display:flex><span>    F1(<span style=color:#8be9fd>int</span> x)<span style=color:#ff79c6>:</span> x(x) { };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>operator</span>()(<span style=color:#8be9fd>int</span> y) <span style=color:#ff79c6>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>return</span> x <span style=color:#ff79c6>+</span> y;
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>F1 <span style=color:#50fa7b>f1</span>(<span style=color:#bd93f9>0</span>);
</span></span><span style=display:flex><span>f1(<span style=color:#bd93f9>1</span>);
</span></span></code></pre></div><h2 id=initializing-variables-in-capture>Initializing Variables in Capture</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>auto</span> f <span style=color:#ff79c6>=</span> [y <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>](<span style=color:#8be9fd>int</span> x) { <span style=color:#ff79c6>return</span> x <span style=color:#ff79c6>+</span> y};
</span></span></code></pre></div><h2 id=const-behavior>Const Behavior</h2><p>A const behavior is a behavior within which any attributes can&rsquo;t be modified.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>class</span> <span style=color:#50fa7b>F1</span> {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> x;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> y;
</span></span><span style=display:flex><span><span style=color:#ff79c6>public</span><span style=color:#ff79c6>:</span> 
</span></span><span style=display:flex><span>    F1(<span style=color:#8be9fd>int</span> x)<span style=color:#ff79c6>:</span> x(x) { };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>operator</span>()(<span style=color:#8be9fd>int</span> y) <span style=color:#ff79c6>const</span> {
</span></span><span style=display:flex><span>        y<span style=color:#ff79c6>++</span>; <span style=color:#6272a4>// fail to compile
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>        <span style=color:#ff79c6>return</span> x <span style=color:#ff79c6>+</span> y;
</span></span><span style=display:flex><span>    } 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=mutating-lambda-member-variables>Mutating Lambda Member Variables</h2><p>Lambda function is a class and its call operator is by default const behavior. We must explicitly define a lambda as mutable.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>[number <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>1</span>]() <span style=color:#ff79c6>mutable</span> {
</span></span><span style=display:flex><span>    number<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=capture-all>Capture All</h2><p>Capture all by value</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>[<span style=color:#ff79c6>=</span>]() {};
</span></span></code></pre></div><p>Capture all by reference</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>[<span style=color:#ff79c6>&amp;</span>]() {};
</span></span></code></pre></div><h2 id=stdfunction>std::function</h2><p>The signature is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>std<span style=color:#ff79c6>::</span>function<span style=color:#ff79c6>&lt;</span>return_type(parameter0, parameter1, ...)<span style=color:#ff79c6>&gt;</span>
</span></span></code></pre></div><p>Lambda functions sharing the same signature can be held by the same type of std::function objects.</p><p>Note that however we can assign a lambda to a std::function of the same signature, a lambda isn&rsquo;t of the type std::function, but is just a class with call operator.</p><h2 id=generic-lambdas>Generic Lambdas</h2><p>A generic lambda is a lambda accepting auto parameters, making it possible to invoke it with any type</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#ff79c6>auto</span> greater <span style=color:#ff79c6>=</span> [](<span style=color:#ff79c6>auto</span> a, <span style=color:#ff79c6>auto</span> b) {<span style=color:#ff79c6>return</span> a <span style=color:#ff79c6>&gt;</span> b <span style=color:#ff79c6>?</span> <span style=color:#8be9fd;font-style:italic>a</span> : b};
</span></span><span style=display:flex><span>greater(<span style=color:#bd93f9>1</span>, <span style=color:#bd93f9>2</span>) <span style=color:#6272a4>//2
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>greater(<span style=color:#bd93f9>1.2f</span>, <span style=color:#bd93f9>1.4f</span>) <span style=color:#6272a4>// 1.4f
</span></span></span></code></pre></div></article></div></section><section id=footer class="footer max-body-width"><div class=footer-wrap><p class=copyright>Blog</p></div><div class=footer-wrap><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a><span> | </span><a href=/index.xml target=_blank rel=noopener>RSS</a></div><div class=footer-wrap><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank rel=noopener>Hugo</a><span> and the </span><a href=https://github.com/qdzhang/hugo-notepadium-mod target=_blank rel=noopener>Notepadium-mod</a></p></div><div class=footer-wrap><a onclick='window.scrollTo({top:0,behavior:"smooth"})'>^ TOP ^</a></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></div></body></html>