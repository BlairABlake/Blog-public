<!doctype html><html><head><meta charset=utf-8><meta name=generator content="Hugo 0.107.0"><meta name=viewport content="width=device-width,initial-scale=1,viewport-fit=cover"><meta name=color-scheme content="light dark"><meta name=supported-color-schemes content="light dark"><meta name=keywords content><meta name=description content="A note on the basic data structure in C"><meta name=author content="Kaga Ryousuke"><meta name=copyright content="Kaga Ryousuke"><meta http-equiv=content-language content="zh,en"><link rel=canonical href=http://blairablakeblog.s3-website-ap-northeast-1.amazonaws.com/c/c-datastructures/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><meta name=msapplication-TileColor content="#da532c"><meta name=theme-color content="#ffffff"><title>Data structures in C&nbsp;&ndash;&nbsp;Blog</title><link rel=preconnect href=https://cdn.jsdelivr.net/ crossorigin><link rel=dns-prefetch href=https://cdn.jsdelivr.net/><link rel=dns-prefetch href=https://fonts.gstatic.com/><link rel=preload href=/css/core.min.7fea1f5a41ad0e665eeb874055b0e68e8a11091c60801d2e241269731df6f3b4cd1871c64da457ede9e3d44dcee5732b.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=/css/core.min.7fea1f5a41ad0e665eeb874055b0e68e8a11091c60801d2e241269731df6f3b4cd1871c64da457ede9e3d44dcee5732b.css integrity=sha384-f+ofWkGtDmZe64dAVbDmjooRCRxggB0uJBJpcx3287TNGHHGTaRX7enj1E3O5XMr></noscript><style type=text/css>*,::before,::after{margin:0;padding:0;box-sizing:border-box}html{font-family:-system-ui,-apple-system,BlinkMacSystemFont,helvetica neue,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol;font-size:17px;font-weight:400;line-height:2;scroll-behavior:smooth;transition:color .3s,background-color .3s;word-wrap:break-word;-webkit-text-size-adjust:100%}html[data-theme=dark] img{opacity:.7;transition:opacity .5s ease-in-out}html{background:#fff;--site-name-color:#3f4b67;--color-primary:#005ab4;--link-underline:#90cff9;--blockquote-border-left:6px solid #0051a2;--block-background-color:#f7faff;--pag-background-color:rgba(0, 122, 255, .5);--box-shadow:1px 1px 2px rgba(0,0,0,.125);--title-color:#303033;--body-color:#444}html[data-theme=dark]{background:#22272e;--site-name-color:#539bf5;--color-primary:#99bde1;--link-underline:#0051a2;--blockquote-border-left:6px solid #5176bf;--block-background-color:#002c58;--box-shadow:none;--title-color:#dadada;--body-color:#e9e9e9}h1,h2,h3,h4,h5,h6{font-weight:600;line-height:1;margin-block-start:0;margin-block-end:0}h1{font-size:26px}h2{font-size:24px}h3{font-size:22px}section>h1{color:var(--title-color)}a{color:var(--color-primary);text-decoration-thickness:.2rem;text-decoration-color:var(--link-underline)}a:hover{text-decoration-color:var(--color-primary)}.wrapper{display:grid;grid-template-columns:1fr min(65ch,calc(100% - 64px))1fr;grid-column-gap:32px}.wrapper>section{grid-column:2}.header{margin:20px 0;display:-webkit-flex;display:flex;flex-wrap:wrap;text-align:initial;padding:15px 0;border-bottom:1px solid #f0f0f0;justify-content:space-between;align-items:baseline}.site-name{display:inline-block;font-weight:600;font-size:21px;color:var(--site-name-color)}.site-logo{height:38px;border-radius:3px;vertical-align:middle;margin-right:8px}.nav-item{display:inline-block;font-size:18px;padding:4px 6px;margin:2px 3px 2px 0;line-height:2;white-space:nowrap}.data-theme-btn{border:none;vertical-align:middle;transition:.3s;background-color:Transparent;background-repeat:no-repeat;cursor:pointer;overflow:hidden;outline:none;padding-right:0;padding-left:0}html[data-theme=light] .light-hidden{display:none}html[data-theme=dark] .dark-hidden{display:none}.note-list{margin:0;padding:0;list-style:none}.note-list .item{position:relative;width:100%;margin-top:25px}.note-list .item:last-child{border:0!important}.note-title{font-size:19px;font-weight:700}.note-date,.note-content{font-size:15px;text-decoration:none;color:var(--body-color)}.note-content,.note-imgs,.note-labels{margin-top:4px;text-align:justify;text-justify:inter-word}.article-tag,.article-category{display:inline-block;font-size:15px;line-height:1;padding:4px 6px;margin:2px 3px 2px 0;white-space:nowrap;border-radius:3px}.article-category{color:#3a8c42}.article-category .hashtag,.article-tag .hashtag{font-weight:700;opacity:.5}.footer{font-size:13px;margin:40px 0 20px}.footer-wrap{text-align:center;color:var(--body-color)}.tag-cloud{margin:2em 0 3em;text-align:center}.tag-cloud-tags{display:inline-block;position:relative;margin:5px;word-wrap:break-word;overflow-wrap:break-word}.archive-year{font-size:20px;font-weight:800;color:var(--title-color);margin-top:20px;margin-bottom:10px}.archive-list{list-style:none}.archive-date{flex:0 0 100px;color:var(--title-color)}.archive-text{color:var(--body-color)}ul.archive-list li{display:flex}.article-containter{margin-bottom:20px}.article-header{margin:20px 0}.article-date{font-size:14px;margin-top:20px;color:#838387}.lastmod-date{font-size:14px;color:#838387}.markdown-body{color:var(--body-color)}.markdown-body p{margin-top:0;margin-bottom:20px}.pagination{display:block;text-align:center;margin:20px 0 40px}.pagination ul{display:inline-block;list-style:none;font-weight:600;padding:0;margin:0}.pagination ul li{display:inline}.pagination ul li a{color:var(--color-primary);float:left;padding:8px 16px;text-decoration:none}.pagination ul li a:hover:not(.active){background-color:var(--pag-background-color)}.pagination ul li a.active{background-color:var(--color-primary);color:var(--block-background-color)}</style></head><body><div class=wrapper><section id=header class=header><div class=header-left><a href=/><img class=site-logo src=/images/logo.jpg alt><p class=site-name>Blog</p></a></div><div class=header-right><div class=nav><a class=nav-item href=/>Index</a><a class=nav-item href=/tags/>Tags</a><a class=nav-item href=/archives/>Archives</a><a class=nav-item href=/about/>About</a><script>const htmlEl=document.getElementsByTagName("html")[0],currentTheme=localStorage.getItem("theme")?localStorage.getItem("theme"):null;currentTheme&&(htmlEl.dataset.theme=currentTheme);const toggleTheme=e=>{htmlEl.dataset.theme=e,localStorage.setItem("theme",e)};toggleTheme("light")</script></div></div></section><section id=content><div class=article-containter><section class=article-header><h1>Data structures in C</h1><p class=article-date>2023-09-10</p></section><section class=article-labels><a class="article-tag li" href=/tags/c/><span class=hashtag>#</span>c</a><a class="article-tag li" href=/tags/programming/><span class=hashtag>#</span>programming</a></section><article class=markdown-body><h1 id=linked-list>Linked List</h1><p><a target=_blank rel="noopener noreferrer" href=/images/linked-list.png><img loading=lazy src=/images/linked-list.png width=100% height=auto alt="Linked List"></a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#ff79c6>struct</span> ll_node {
</span></span><span style=display:flex><span>    data_type data;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> ll_node <span style=color:#ff79c6>*</span>next;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=traversing>Traversing</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#ff79c6>struct</span> ll_node <span style=color:#ff79c6>*</span>ptr <span style=color:#ff79c6>=</span> start;
</span></span><span style=display:flex><span><span style=color:#ff79c6>while</span>(ptr <span style=color:#ff79c6>!=</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) {
</span></span><span style=display:flex><span>    statements
</span></span><span style=display:flex><span>    ptr <span style=color:#ff79c6>=</span> ptr<span style=color:#ff79c6>-&gt;</span>next;
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><h2 id=traversing-using-recursion>Traversing using recursion</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>func</span>(<span style=color:#ff79c6>struct</span> ll_node <span style=color:#ff79c6>*</span>node) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(node <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    statements
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>func</span>(node<span style=color:#ff79c6>-&gt;</span>next);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=insertion>Insertion</h2><p>Basic ideas is connecting a new node beween the nodes by overwriting the existing connections.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#ff79c6>struct</span> ll_node <span style=color:#ff79c6>*</span>next <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>next;
</span></span><span style=display:flex><span>new_node<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>=</span> next; <span style=color:#6272a4>// connecting a new node
</span></span></span><span style=display:flex><span><span style=color:#6272a4></span>node<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>=</span> new_node; <span style=color:#6272a4>// overwrting a existing connection
</span></span></span></code></pre></div><p><strong>If the node is the last node</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#ff79c6>if</span>(node<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) {
</span></span><span style=display:flex><span>    node<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>=</span> new_node; 
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>If the node is the first node</strong> (there is no way to check if the node is the first node)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>new_node<span style=color:#ff79c6>-&gt;</span>next <span style=color:#ff79c6>=</span> node;
</span></span></code></pre></div><h1 id=linked-list-versus-arrays>Linked List Versus Arrays</h1><h2 id=arrays>Arrays</h2><ul><li>constant-time access</li><li>space efficient</li><li>memory are stored continuously ( physically continuous )</li><li>fixed size</li></ul><h2 id=linked-list-1>Linked List</h2><ul><li>requires extra memory for storing pointer</li><li>overflow never occurs</li><li>dynamic size</li></ul><h1 id=dynamic-array>Dynamic Array</h1><p>If the memory runs out, allocate the double size of memory and copies the original data, and free the original memory
<a target=_blank rel="noopener noreferrer" href=/images/dynamic-array.png><img loading=lazy src=/images/dynamic-array.png width=100% height=auto alt="Dynamic Array"></a></p><h1 id=stacks>Stacks</h1><p>Stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle.</p><p>Data will be added on top of the pile; push operation.</p><p>The top-most data will be removed first; pop operation.</p><p>You can peek the top item without removing; peek operation.</p><p><a target=_blank rel="noopener noreferrer" href=/images/stack.png><img loading=lazy src=/images/stack.png width=100% height=auto alt=Stack></a></p><h2 id=array-representation>Array representation</h2><p><a target=_blank rel="noopener noreferrer" href=/images/stack-array.png><img loading=lazy src=/images/stack-array.png width=100% height=auto alt="Stack array"></a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> stack {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> top;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> capacity;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> <span style=color:#ff79c6>*</span>arr;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h2 id=creating-stack>creating stack</h2><p>I use macro to create a stack</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#define stack_create(size) (struct stack){ -1, size, (int*)malloc(sizeof(int) * size)}
</span></span></span></code></pre></div><p>Other utilities macros are</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#define stack_full(st) st-&gt;top == st-&gt;capacity - 1
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#define stack_empty(st) st-&gt;top == -1
</span></span></span><span style=display:flex><span><span style=color:#ff79c6>#define stack_top(st) st-&gt;arr[st-&gt;top]
</span></span></span></code></pre></div><h2 id=push-operation>push operation</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>stack_push</span>(<span style=color:#ff79c6>struct</span> stack <span style=color:#ff79c6>*</span>st, <span style=color:#8be9fd>int</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(st<span style=color:#ff79c6>-&gt;</span>top <span style=color:#ff79c6>==</span> st<span style=color:#ff79c6>-&gt;</span>size <span style=color:#ff79c6>-</span> <span style=color:#bd93f9>1</span>) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    st<span style=color:#ff79c6>-&gt;</span>top<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>    st<span style=color:#ff79c6>-&gt;</span>data[st<span style=color:#ff79c6>-&gt;</span>top] <span style=color:#ff79c6>=</span> data;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=pop-operation>pop operation</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>stack_pop</span>(<span style=color:#ff79c6>struct</span> stack <span style=color:#ff79c6>*</span>st) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(<span style=color:#50fa7b>stack_empty</span>(st)) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> val <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>stack_top</span>(st);
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>stack_top</span>(st) <span style=color:#ff79c6>=</span> <span style=color:#bd93f9>0</span>;
</span></span><span style=display:flex><span>    st<span style=color:#ff79c6>-&gt;</span>top<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> val;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=queue>Queue</h1><p>Queue is a linear data structure that follows the First-In-Last-Out (FIFO) principle.</p><p>Data will be added at the last of the array; enqueue operation</p><p>The data added first will be remove first; dequeue operation</p><p><a target=_blank rel="noopener noreferrer" href=/images/queue.png><img loading=lazy src=/images/queue.png width=100% height=auto alt=Queue></a></p><p>I use a linked list to represent a queue</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> queue {
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> capacity;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> size;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> dll_node <span style=color:#ff79c6>*</span>last;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> dll_node <span style=color:#ff79c6>*</span>first;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>enqueue</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>void</span> <span style=color:#50fa7b>enqueue</span>(<span style=color:#ff79c6>struct</span> queue <span style=color:#ff79c6>*</span>q, <span style=color:#8be9fd>int</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(q<span style=color:#ff79c6>-&gt;</span>size <span style=color:#ff79c6>&gt;=</span> q<span style=color:#ff79c6>-&gt;</span>capacity) <span style=color:#ff79c6>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(q<span style=color:#ff79c6>-&gt;</span>size <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>) {
</span></span><span style=display:flex><span>        q<span style=color:#ff79c6>-&gt;</span>last <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>dll_create</span>(data);
</span></span><span style=display:flex><span>        q<span style=color:#ff79c6>-&gt;</span>first <span style=color:#ff79c6>=</span> q<span style=color:#ff79c6>-&gt;</span>last;
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        q<span style=color:#ff79c6>-&gt;</span>first <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>dll_insert_before_this</span>(q<span style=color:#ff79c6>-&gt;</span>first, <span style=color:#50fa7b>dll_create</span>(data)); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    q<span style=color:#ff79c6>-&gt;</span>size<span style=color:#ff79c6>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>dequeue</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#8be9fd>int</span> <span style=color:#50fa7b>dequeue</span>(<span style=color:#ff79c6>struct</span> queue <span style=color:#ff79c6>*</span>q) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(q<span style=color:#ff79c6>-&gt;</span>size <span style=color:#ff79c6>==</span> <span style=color:#bd93f9>0</span>) <span style=color:#ff79c6>return</span> <span style=color:#ff79c6>-</span><span style=color:#bd93f9>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> data <span style=color:#ff79c6>=</span> q<span style=color:#ff79c6>-&gt;</span>last<span style=color:#ff79c6>-&gt;</span>data;
</span></span><span style=display:flex><span>    q<span style=color:#ff79c6>-&gt;</span>last <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>dll_delete_this</span>(q<span style=color:#ff79c6>-&gt;</span>last);
</span></span><span style=display:flex><span>    q<span style=color:#ff79c6>-&gt;</span>size<span style=color:#ff79c6>--</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> data;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=tree>Tree</h1><h2 id=terminologies>Terminologies</h2><ul><li>root node: the top most node in the tree</li><li>leaf node: a node that has no children</li><li>path: a sequence of consecutive edges</li><li>ancestor node: any predecessor node on the path from the node to a leaf node.</li><li>descendent node: any successor node on any path from the node to a leaf node.</li><li>degree: the number of children</li></ul><h2 id=binary-tree>Binary tree</h2><p><a target=_blank rel="noopener noreferrer" href=/images/binary-tree.png><img loading=lazy src=/images/binary-tree.png width=100% height=auto alt="Binary Tree"></a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> bt_node {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>left;
</span></span><span style=display:flex><span>    <span style=color:#8be9fd>int</span> data;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>right;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>is it a leaf?</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>#define bt_is_leaf(node) (node-&gt;left == NULL &amp;&amp; node-&gt;right == NULL)
</span></span></span></code></pre></div><p><strong>Basic operations</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span><span style=color:#50fa7b>bt_create</span>(<span style=color:#8be9fd>int</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>node <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>malloc</span>(<span style=color:#ff79c6>sizeof</span>(<span style=color:#ff79c6>struct</span> bt_node));
</span></span><span style=display:flex><span>    node<span style=color:#ff79c6>-&gt;</span>data <span style=color:#ff79c6>=</span> data;
</span></span><span style=display:flex><span>    node<span style=color:#ff79c6>-&gt;</span>right <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>    node<span style=color:#ff79c6>-&gt;</span>left <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> node;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span><span style=color:#50fa7b>bt_insert_left</span>(<span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>node, <span style=color:#8be9fd>int</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>new_node <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>bt_create</span>(data);
</span></span><span style=display:flex><span>    node<span style=color:#ff79c6>-&gt;</span>left <span style=color:#ff79c6>=</span> new_node;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> new_node;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span><span style=color:#50fa7b>bt_insert_right</span>(<span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>node, <span style=color:#8be9fd>int</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>new_node <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>bt_create</span>(data);
</span></span><span style=display:flex><span>    node<span style=color:#ff79c6>-&gt;</span>right <span style=color:#ff79c6>=</span> new_node;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> new_node;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h1 id=binary-search-tree>Binary Search Tree</h1><p>Binary search tree is a type of binary tree with the following recursive properties.</p><ul><li>The left subtree of a node contains only nodes with keys lesser than the node’s key.</li><li>The right subtree of a node contains only nodes with keys greater than the node’s key.</li></ul><h2 id=insertion-1>Insertion</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span><span style=color:#50fa7b>bst_insert</span>(<span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>node, <span style=color:#8be9fd>int</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(<span style=color:#50fa7b>bt_is_leaf</span>(node)) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(node<span style=color:#ff79c6>-&gt;</span>data <span style=color:#ff79c6>&lt;=</span> data) node<span style=color:#ff79c6>-&gt;</span>right <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>bt_create</span>(data);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> node<span style=color:#ff79c6>-&gt;</span>left <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>bt_create</span>(data);
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(node<span style=color:#ff79c6>-&gt;</span>data <span style=color:#ff79c6>&lt;=</span> data) <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>bst_insert</span>(node<span style=color:#ff79c6>-&gt;</span>right, data);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>bst_insert</span>(node<span style=color:#ff79c6>-&gt;</span>left, data);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=searching>Searching</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span><span style=color:#50fa7b>bst_search</span>(<span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>node, <span style=color:#8be9fd>int</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(node <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(node<span style=color:#ff79c6>-&gt;</span>data <span style=color:#ff79c6>==</span> data) <span style=color:#ff79c6>return</span> node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>left <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>left, <span style=color:#ff79c6>*</span>right <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>right;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(left <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span> <span style=color:#ff79c6>&amp;&amp;</span> right <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span>(left <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span> <span style=color:#ff79c6>&amp;&amp;</span> data <span style=color:#ff79c6>&lt;</span> node<span style=color:#ff79c6>-&gt;</span>data) <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span>(right <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span> <span style=color:#ff79c6>&amp;&amp;</span> data <span style=color:#ff79c6>&gt;=</span> node<span style=color:#ff79c6>-&gt;</span>data) <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>if</span>(data <span style=color:#ff79c6>&lt;</span> node<span style=color:#ff79c6>-&gt;</span>data) <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>bst_search</span>(node<span style=color:#ff79c6>-&gt;</span>left, data);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>bst_search</span>(node<span style=color:#ff79c6>-&gt;</span>right, data);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=merging>Merging</h2><p>The idea is the same as insertion; inserting a root node, &ldquo;node&rdquo; to the tree &ldquo;tnode&rdquo;</p><p>Since the binary tree is a <strong>recursive structure</strong>, this is fine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span><span style=color:#50fa7b>bst_merge</span>(<span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>tnode, <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>node) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(node <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span> <span style=color:#ff79c6>||</span> tnode <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(<span style=color:#50fa7b>bt_is_leaf</span>(tnode)) {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(tnode<span style=color:#ff79c6>-&gt;</span>data <span style=color:#ff79c6>&lt;=</span> node<span style=color:#ff79c6>-&gt;</span>data) tnode<span style=color:#ff79c6>-&gt;</span>right <span style=color:#ff79c6>=</span> node;
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> tnode<span style=color:#ff79c6>-&gt;</span>left <span style=color:#ff79c6>=</span> node;
</span></span><span style=display:flex><span>    } <span style=color:#ff79c6>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>if</span>(tnode<span style=color:#ff79c6>-&gt;</span>data <span style=color:#ff79c6>&lt;=</span> node<span style=color:#ff79c6>-&gt;</span>data) <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>bst_merge</span>(tnode<span style=color:#ff79c6>-&gt;</span>right, node);
</span></span><span style=display:flex><span>        <span style=color:#ff79c6>else</span> <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>bst_merge</span>(tnode<span style=color:#ff79c6>-&gt;</span>left, node);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=deleting>Deleting</h2><p>The idea is that first delete a connection to the traget node &ldquo;node&rdquo;, and merge the children to the root node &ldquo;root&rdquo;.</p><p><strong>Utility function</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span><span style=color:#50fa7b>bst_delete_this</span>(<span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>root, <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>node) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>if</span>(node <span style=color:#ff79c6>==</span> <span style=color:#8be9fd;font-style:italic>NULL</span>) <span style=color:#ff79c6>return</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>left <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>left, <span style=color:#ff79c6>*</span>right <span style=color:#ff79c6>=</span> node<span style=color:#ff79c6>-&gt;</span>right;
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>free</span>(node);
</span></span><span style=display:flex><span>    node <span style=color:#ff79c6>=</span> <span style=color:#8be9fd;font-style:italic>NULL</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>bst_merge</span>(root, left);
</span></span><span style=display:flex><span>    <span style=color:#50fa7b>bst_merge</span>(root, right);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> root;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>and deletion</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span><span style=color:#50fa7b>bst_delete</span>(<span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>node, <span style=color:#8be9fd>int</span> data) {
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>struct</span> bt_node <span style=color:#ff79c6>*</span>target <span style=color:#ff79c6>=</span> <span style=color:#50fa7b>bst_search</span>(node, data);
</span></span><span style=display:flex><span>    <span style=color:#ff79c6>return</span> <span style=color:#50fa7b>bst_delete_this</span>(node, target);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></article></div><section class=article-navigation><p><a class=link href=/c/c-compiling/><span class=li></span>Compiling C</a></p><p><a class=link href=/c/unix/><span class=li></span>Unix and C</a class="link"></p></section></section><section id=footer class="footer max-body-width"><div class=footer-wrap><p class=copyright>Blog</p></div><div class=footer-wrap><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh target=_blank rel=noopener>CC BY-NC-SA 4.0</a><span> | </span><a href=/index.xml target=_blank rel=noopener>RSS</a></div><div class=footer-wrap><p class=powerby><span>Powered by </span><a href=https://gohugo.io target=_blank rel=noopener>Hugo</a><span> and the </span><a href=https://github.com/qdzhang/hugo-notepadium-mod target=_blank rel=noopener>Notepadium-mod</a></p></div><div class=footer-wrap><a onclick='window.scrollTo({top:0,behavior:"smooth"})'>^ TOP ^</a></div></section><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css integrity=sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.js integrity=sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/contrib/auto-render.min.js integrity=sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI crossorigin=anonymous onload=renderMathInElement(document.body)></script></div></body></html>